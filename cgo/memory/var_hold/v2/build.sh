#! /bin/bash

# g++(gcc)编译选项
# 	-shared ：指定生成动态链接库。
# 	-static ：指定生成静态链接库。
# 	-fPIC ：表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码， 念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方。
# 	-L. ：表示要连接的库所在的目录。
# 	-l：指定链接时需要的动态库。编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a/.so来确定库的名称。
# 	-Wall ：生成所有警告信息。
# 	-ggdb ：此选项将尽可能的生成gdb 的可以使用的调试信息。
# 	-g ：编译器在编译的时候产生调试信息。
# 	-c ：只激活预处理、编译和汇编,也就是把程序做成目标文件(.o文件) 。
# 	-Wl,options ：把参数(options)传递给链接器ld 。如果options 中间有逗号,就将options分成多个选项,然后传递给链接程序。

# nm命令
# 有时候可能需要查看一个库中到底有哪些函数，nm命令可以打印出库中的涉及到的所有符号。库既可以是静态的也可以是动态的。nm列出的符号有很多，常见的有三种：
# 	一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；
# 	一种是库中定义的函数，用T表示，这是最常见的；
# 	一种是所谓的弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。

# ldd命令
# ldd命令可以查看一个可执行程序依赖的共享库

# 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库，因此体积较大。
# 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在，因此代码体积较小。
# 动态库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例

# 静态库
go build -buildmode=c-archive -o ./c/libgostring.a gostring.go object.go main.go
# 构建
gcc -lpthread -o gostring ./c/main.c  -L./c -lgostring
# 运行
./gostring


# 动态库
go build -buildmode=c-shared -o c/libgostring.so gostring.go  object.go  main.go
# 构建
gcc -o gostring ./c/main.c  ./c/libgostring.so
# 运行
LD_LIBRARY_PATH=./c ./gostring

